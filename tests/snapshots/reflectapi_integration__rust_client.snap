---
source: tests/reflectapi_integration.rs
expression: generated
---
// DO NOT MODIFY THIS FILE MANUALLY
// This file was generated by reflectapi-cli
//
// Schema name: Hotspots Test API
// Test API for validating reflectapi serialization

#![allow(non_camel_case_types)]
#![allow(dead_code)]

pub use reflectapi::rt::*;
pub use interface::Interface;

pub mod interface {

#[derive(Debug)]
pub struct Interface<C: reflectapi::rt::Client + Clone> {
    client: C,
    base_url: reflectapi::rt::Url,
}

impl<C: reflectapi::rt::Client + Clone> Interface<C> {
    pub fn try_new(client: C, base_url: reflectapi::rt::Url) -> std::result::Result<Self, reflectapi::rt::UrlParseError> {
        if base_url.cannot_be_a_base() {
            return Err(reflectapi::rt::UrlParseError::RelativeUrlWithCannotBeABaseBase);
        }

        Ok(Self {
            client,
            base_url,
        })
    }
    /// Echoes back the provided coordinate
    pub async fn echo_coordinate(&self, input: (u32, u32), headers: reflectapi::Empty)
    -> Result<(u32, u32), reflectapi::rt::Error<reflectapi::Empty, C::Error>> {
        reflectapi::rt::__request_impl(&self.client, self.base_url.join("/echo_coordinate").expect("checked base_url already and path is valid"), input, headers).await
    }
    /// Echoes back the provided hotspot
    pub async fn echo_hotspot(&self, input: super::types::Hotspot, headers: reflectapi::Empty)
    -> Result<super::types::Hotspot, reflectapi::rt::Error<reflectapi::Empty, C::Error>> {
        reflectapi::rt::__request_impl(&self.client, self.base_url.join("/echo_hotspot").expect("checked base_url already and path is valid"), input, headers).await
    }
}

}
pub mod types {

/// A rectangular hotspot represented as a rectangle with two corners.
#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub struct Hotspot {
    pub x1: u32,
    pub y1: u32,
    pub x2: u32,
    pub y2: u32,
}










}
